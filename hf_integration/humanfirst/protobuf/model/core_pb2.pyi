"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.timestamp_pb2
import playbook.entity_pb2
import sys
import tags.tags_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ConversationType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ConversationTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ConversationType.ValueType], builtins.type):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CONVERSATION_TYPE_TWO_WAY: _ConversationType.ValueType  # 0
    """Two way conversation that can contain agent and client inputs."""
    CONVERSATION_TYPE_UTTERANCE: _ConversationType.ValueType  # 2
    """Single utterance conversation."""
    CONVERSATION_TYPE_DOCUMENT: _ConversationType.ValueType  # 3
    """Document conversation."""
    CONVERSATION_TYPE_UNSPECIFIED: _ConversationType.ValueType  # 1
    """Unspecified conversation type.
    To prevent recrunching all conversations, and since most are two way, we default the enum to two way
    """

class ConversationType(_ConversationType, metaclass=_ConversationTypeEnumTypeWrapper): ...

CONVERSATION_TYPE_TWO_WAY: ConversationType.ValueType  # 0
"""Two way conversation that can contain agent and client inputs."""
CONVERSATION_TYPE_UTTERANCE: ConversationType.ValueType  # 2
"""Single utterance conversation."""
CONVERSATION_TYPE_DOCUMENT: ConversationType.ValueType  # 3
"""Document conversation."""
CONVERSATION_TYPE_UNSPECIFIED: ConversationType.ValueType  # 1
"""Unspecified conversation type.
To prevent recrunching all conversations, and since most are two way, we default the enum to two way
"""
global___ConversationType = ConversationType

class _EventType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EventTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EventType.ValueType], builtins.type):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EVENT_TYPE_INVALID: _EventType.ValueType  # 0
    """Invalid. This message does not represent an event."""
    EVENT_TYPE_CONVERSATION_ENDED: _EventType.ValueType  # 1
    """The conversation has ended.
    This event has additional metadata information.

    *reason*
        visitor_disconnected: The customer has disconnected
        visitor_closed: The visitor has explicitly closed the conversation
        agent_signed_out: The chat was closed because the agent handling the conversation signed out from the platform
        agent_closed: The agent explicitly closed the conversation
    """

class EventType(_EventType, metaclass=_EventTypeEnumTypeWrapper): ...

EVENT_TYPE_INVALID: EventType.ValueType  # 0
"""Invalid. This message does not represent an event."""
EVENT_TYPE_CONVERSATION_ENDED: EventType.ValueType  # 1
"""The conversation has ended.
This event has additional metadata information.

*reason*
    visitor_disconnected: The customer has disconnected
    visitor_closed: The visitor has explicitly closed the conversation
    agent_signed_out: The chat was closed because the agent handling the conversation signed out from the platform
    agent_closed: The agent explicitly closed the conversation
"""
global___EventType = EventType

class _ConversationsImportFormat:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ConversationsImportFormatEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ConversationsImportFormat.ValueType], builtins.type):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    IMPORT_FORMAT_INVALID: _ConversationsImportFormat.ValueType  # 0
    IMPORT_FORMAT_SIMPLE_CSV: _ConversationsImportFormat.ValueType  # 1
    IMPORT_FORMAT_UTTERANCES_TXT: _ConversationsImportFormat.ValueType  # 2
    IMPORT_FORMAT_RASA_EVENTS_JSONL: _ConversationsImportFormat.ValueType  # 3
    IMPORT_FORMAT_HUMANFIRST_JSON: _ConversationsImportFormat.ValueType  # 4

class ConversationsImportFormat(_ConversationsImportFormat, metaclass=_ConversationsImportFormatEnumTypeWrapper): ...

IMPORT_FORMAT_INVALID: ConversationsImportFormat.ValueType  # 0
IMPORT_FORMAT_SIMPLE_CSV: ConversationsImportFormat.ValueType  # 1
IMPORT_FORMAT_UTTERANCES_TXT: ConversationsImportFormat.ValueType  # 2
IMPORT_FORMAT_RASA_EVENTS_JSONL: ConversationsImportFormat.ValueType  # 3
IMPORT_FORMAT_HUMANFIRST_JSON: ConversationsImportFormat.ValueType  # 4
global___ConversationsImportFormat = ConversationsImportFormat

class Conversation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _State:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Conversation._State.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        PENDING: Conversation._State.ValueType  # 0
        """* The conversation is still in progress"""
        FINAL_PENDING: Conversation._State.ValueType  # 2
        """* The conversation has been marked as finished and needs to be finalized to be integrated into the main model"""
        FINAL: Conversation._State.ValueType  # 1
        """* The conversation has been integrated in the main model"""

    class State(_State, metaclass=_StateEnumTypeWrapper): ...
    PENDING: Conversation.State.ValueType  # 0
    """* The conversation is still in progress"""
    FINAL_PENDING: Conversation.State.ValueType  # 2
    """* The conversation has been marked as finished and needs to be finalized to be integrated into the main model"""
    FINAL: Conversation.State.ValueType  # 1
    """* The conversation has been integrated in the main model"""

    class AgentsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___Agent: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___Agent | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    class Input(google.protobuf.message.Message):
        """Represents a single user or expert input inside a conversation"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class MetadataEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: builtins.str
            value: builtins.str
            def __init__(
                self,
                *,
                key: builtins.str = ...,
                value: builtins.str = ...,
            ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

        ID_FIELD_NUMBER: builtins.int
        NORMALIZED_ID_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        HASH_FIELD_NUMBER: builtins.int
        METADATA_FIELD_NUMBER: builtins.int
        CREATED_AT_FIELD_NUMBER: builtins.int
        TYPE_FIELD_NUMBER: builtins.int
        SOURCE_FIELD_NUMBER: builtins.int
        AGENT_ID_FIELD_NUMBER: builtins.int
        EVENT_TYPE_FIELD_NUMBER: builtins.int
        FORM_DATA_FIELD_NUMBER: builtins.int
        TAGS_FIELD_NUMBER: builtins.int
        id: builtins.str
        """Input ID generated by reconciliation / merge job. It's based on a hash of text value, creation date and source"""
        normalized_id: builtins.str
        """This field is only present in the context of a search result from QueryConversations.

        Normalized ids can be used with the recommender API and have the following format:
        conversations/<input id>
           for conversation inputs from a playbook index
        phrase-id
           for phrases present in the current workspace
        index/<namespace>/<convset id>/<version>/<id>
           for inputs resulting from a conversation set vector lookup

        If a conversation input matches an existing training phrase, this will contain the phrase id of the matching phrase.
        If it does not, it will contain "conversations/<input_id>"
        """
        value: builtins.str
        """The verbatim text value"""
        hash: builtins.str
        """Hash of the normalized text value"""
        @property
        def metadata(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
            """Client-provided metadata"""
        @property
        def created_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The timestamp at which this input was uttered"""
        type: builtins.str
        """The type of input 'suggested-entry', etc. TODO: Turn this into an enum?
        Valid values: "manual-entry", "suggested-entry", "event"
        """
        source: builtins.str
        """Expert or client TODO: Enum?"""
        agent_id: builtins.str
        """If message is source Expert / Agent, the ID of the agent as listed in the conversations `agents` field
        This field value is the key of the `agents` field in conversation.
        """
        event_type: global___EventType.ValueType
        """If the type is "event", specify the type of event this is describing"""
        @property
        def form_data(self) -> google.protobuf.struct_pb2.Struct:
            """flat JSON data provided by user when submitting a Automate form"""
        @property
        def tags(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tags.tags_pb2.TagReference]:
            """Tags for the input. Only used when importing data."""
        def __init__(
            self,
            *,
            id: builtins.str = ...,
            normalized_id: builtins.str = ...,
            value: builtins.str = ...,
            hash: builtins.str = ...,
            metadata: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
            created_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
            type: builtins.str = ...,
            source: builtins.str = ...,
            agent_id: builtins.str = ...,
            event_type: global___EventType.ValueType = ...,
            form_data: google.protobuf.struct_pb2.Struct | None = ...,
            tags: collections.abc.Iterable[tags.tags_pb2.TagReference] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["created_at", b"created_at", "form_data", b"form_data"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["agent_id", b"agent_id", "created_at", b"created_at", "event_type", b"event_type", "form_data", b"form_data", "hash", b"hash", "id", b"id", "metadata", b"metadata", "normalized_id", b"normalized_id", "source", b"source", "tags", b"tags", "type", b"type", "value", b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    SOURCES_FIELD_NUMBER: builtins.int
    CONVERSATION_SET_SOURCE_FIELD_NUMBER: builtins.int
    MODEL_NAME_FIELD_NUMBER: builtins.int
    OWNER_FIELD_NUMBER: builtins.int
    AGENTS_FIELD_NUMBER: builtins.int
    ORGANIZATION_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    APPLICATION_FIELD_NUMBER: builtins.int
    BOUND_FEF_FIELD_NUMBER: builtins.int
    CREATED_AT_FIELD_NUMBER: builtins.int
    UPDATED_AT_FIELD_NUMBER: builtins.int
    PLATFORM_URL_FIELD_NUMBER: builtins.int
    DISTINCT_ID_FIELD_NUMBER: builtins.int
    id: builtins.str
    """A guid generated by the backend"""
    @property
    def sources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConversationSource]:
        """Information about different sources where this conversation was imported from (ex: Mongo + Thrutext)"""
    @property
    def conversation_set_source(self) -> global___ConversationSetSource:
        """Information about conversation set in which this conversation was imported from in the pipeline"""
    model_name: builtins.str
    """Name of the model used"""
    owner: builtins.str
    """The User UID of the user performing this conversation"""
    @property
    def agents(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___Agent]:
        """Agents who acted on the conversation"""
    organization: builtins.str
    """Identifies the name of the organization to which the user performing this conversation belongs"""
    @property
    def metadata(self) -> google.protobuf.struct_pb2.Struct:
        """Client provided metadata"""
    version: builtins.int
    """Version of the model server handling this conversation"""
    @property
    def inputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Conversation.Input]:
        """Series of inputs processed since the initial model"""
    state: global___Conversation.State.ValueType
    """Whether this conversation is in progress or has been closed/finalized"""
    type: global___ConversationType.ValueType
    """Type of conversation (ex: two way, utterance)"""
    @property
    def application(self) -> global___Application:
        """If the conversation was conducted over a HumanFirst application, information about this application."""
    bound_fef: builtins.int
    """(Legacy) The id of the `ref` table entry corresponding to the model being used, if available"""
    @property
    def created_at(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    @property
    def updated_at(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    platform_url: builtins.str
    """The URL which the agent is viewing while having this conversation"""
    distinct_id: builtins.str
    def __init__(
        self,
        *,
        id: builtins.str = ...,
        sources: collections.abc.Iterable[global___ConversationSource] | None = ...,
        conversation_set_source: global___ConversationSetSource | None = ...,
        model_name: builtins.str = ...,
        owner: builtins.str = ...,
        agents: collections.abc.Mapping[builtins.str, global___Agent] | None = ...,
        organization: builtins.str = ...,
        metadata: google.protobuf.struct_pb2.Struct | None = ...,
        version: builtins.int = ...,
        inputs: collections.abc.Iterable[global___Conversation.Input] | None = ...,
        state: global___Conversation.State.ValueType = ...,
        type: global___ConversationType.ValueType = ...,
        application: global___Application | None = ...,
        bound_fef: builtins.int = ...,
        created_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        updated_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        platform_url: builtins.str = ...,
        distinct_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["application", b"application", "conversation_set_source", b"conversation_set_source", "created_at", b"created_at", "metadata", b"metadata", "updated_at", b"updated_at"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["agents", b"agents", "application", b"application", "bound_fef", b"bound_fef", "conversation_set_source", b"conversation_set_source", "created_at", b"created_at", "distinct_id", b"distinct_id", "id", b"id", "inputs", b"inputs", "metadata", b"metadata", "model_name", b"model_name", "organization", b"organization", "owner", b"owner", "platform_url", b"platform_url", "sources", b"sources", "state", b"state", "type", b"type", "updated_at", b"updated_at", "version", b"version"]) -> None: ...

global___Conversation = Conversation

class ModelBinding(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    LEGACY_FIELD_NUMBER: builtins.int
    version: builtins.int
    """The model server version responsible for handling the request"""
    @property
    def legacy(self) -> global___LegacyModelBinding: ...
    def __init__(
        self,
        *,
        version: builtins.int = ...,
        legacy: global___LegacyModelBinding | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["legacy", b"legacy", "type", b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["legacy", b"legacy", "type", b"type", "version", b"version"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type", b"type"]) -> typing_extensions.Literal["legacy"] | None: ...

global___ModelBinding = ModelBinding

class LegacyModelBinding(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REVISION_FIELD_NUMBER: builtins.int
    revision: builtins.str
    def __init__(
        self,
        *,
        revision: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["revision", b"revision"]) -> None: ...

global___LegacyModelBinding = LegacyModelBinding

class AnnotatedConversation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class AnnotationsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> google.protobuf.any_pb2.Any: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: google.protobuf.any_pb2.Any | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    CONVERSATION_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def conversation(self) -> global___Conversation: ...
    @property
    def annotations(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, google.protobuf.any_pb2.Any]:
        """Annotation map, key=annotation type, value=annotation-specific"""
    def __init__(
        self,
        *,
        conversation: global___Conversation | None = ...,
        annotations: collections.abc.Mapping[builtins.str, google.protobuf.any_pb2.Any] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["conversation", b"conversation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotations", b"annotations", "conversation", b"conversation"]) -> None: ...

global___AnnotatedConversation = AnnotatedConversation

class EmbeddingAnnotation(google.protobuf.message.Message):
    """Conversation annotation for embedding for each input"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DIMENSIONS_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    INDEX_POSITIONS_FIELD_NUMBER: builtins.int
    @property
    def dimensions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Contains the shape of the data for a single embedding representation
        The first component is the number of embeddings
        """
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Data for all embeddings under this annotation"""
    @property
    def index_positions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EmbeddingIndexId]:
        """Canonical ID inside the embedding index."""
    def __init__(
        self,
        *,
        dimensions: collections.abc.Iterable[builtins.int] | None = ...,
        data: collections.abc.Iterable[builtins.float] | None = ...,
        index_positions: collections.abc.Iterable[global___EmbeddingIndexId] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["data", b"data", "dimensions", b"dimensions", "index_positions", b"index_positions"]) -> None: ...

global___EmbeddingAnnotation = EmbeddingAnnotation

class EmbeddingIndexId(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEGMENT_ID_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    segment_id: builtins.int
    index: builtins.int
    def __init__(
        self,
        *,
        segment_id: builtins.int = ...,
        index: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["index", b"index", "segment_id", b"segment_id"]) -> None: ...

global___EmbeddingIndexId = EmbeddingIndexId

class MetricAnnotation(google.protobuf.message.Message):
    """Conversation annotation with high level conversation's metrics
    Make sure that the name of the metric is the same as the field in ConversationMetricPredicate
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AGENT_MEAN_RESPONSE_TIME_FIELD_NUMBER: builtins.int
    CLIENT_MEAN_RESPONSE_TIME_FIELD_NUMBER: builtins.int
    AGENT_INPUTS_COUNT_FIELD_NUMBER: builtins.int
    CLIENT_INPUTS_COUNT_FIELD_NUMBER: builtins.int
    INPUTS_COUNT_FIELD_NUMBER: builtins.int
    EXPLICIT_PERSONA_COUNT_FIELD_NUMBER: builtins.int
    PERSONA_COUNT_FIELD_NUMBER: builtins.int
    EXPLICIT_INTENT_INPUT_COUNT_FIELD_NUMBER: builtins.int
    EXPLICIT_INTENT_INPUT_COVERAGE_FIELD_NUMBER: builtins.int
    agent_mean_response_time: builtins.float
    """Mean time before agent responds to client's input (in seconds)"""
    client_mean_response_time: builtins.float
    """Mean time before client responds to agent's input (in seconds)"""
    agent_inputs_count: builtins.int
    """Number of agent inputs"""
    client_inputs_count: builtins.int
    """Number of client inputs"""
    inputs_count: builtins.int
    """Total number of inputs"""
    explicit_persona_count: builtins.int
    """Number of intents that were explicitly annotated (ex: explicitly labeled in an intent)"""
    persona_count: builtins.int
    """Total number of intents (explicit or inferred)"""
    explicit_intent_input_count: builtins.int
    """Number of inputs that were explicitly annotated with an intent (ex: phrase fragment or content match)."""
    explicit_intent_input_coverage: builtins.float
    """Percentage of client inputs that were explicitely annotated with an intent"""
    def __init__(
        self,
        *,
        agent_mean_response_time: builtins.float = ...,
        client_mean_response_time: builtins.float = ...,
        agent_inputs_count: builtins.int = ...,
        client_inputs_count: builtins.int = ...,
        inputs_count: builtins.int = ...,
        explicit_persona_count: builtins.int = ...,
        persona_count: builtins.int = ...,
        explicit_intent_input_count: builtins.int = ...,
        explicit_intent_input_coverage: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["agent_inputs_count", b"agent_inputs_count", "agent_mean_response_time", b"agent_mean_response_time", "client_inputs_count", b"client_inputs_count", "client_mean_response_time", b"client_mean_response_time", "explicit_intent_input_count", b"explicit_intent_input_count", "explicit_intent_input_coverage", b"explicit_intent_input_coverage", "explicit_persona_count", b"explicit_persona_count", "inputs_count", b"inputs_count", "persona_count", b"persona_count"]) -> None: ...

global___MetricAnnotation = MetricAnnotation

class InputsIntentsAnnotation(google.protobuf.message.Message):
    """Conversation annotation to identify intents matching for each input"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _MatchSource:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _MatchSourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[InputsIntentsAnnotation._MatchSource.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        MATCH_SOURCE_INVALID: InputsIntentsAnnotation._MatchSource.ValueType  # 0
        MATCH_SOURCE_INTENT_MODEL: InputsIntentsAnnotation._MatchSource.ValueType  # 1
        """Intent match based on IntentModel on expert/agent or client inputs."""
        MATCH_SOURCE_SUGGESTED_ENTRY: InputsIntentsAnnotation._MatchSource.ValueType  # 2
        """Explicit match based on usage of a suggested entry (or modified suggested entry) by the agent."""
        MATCH_SOURCE_PERSONA_ACTIVATION: InputsIntentsAnnotation._MatchSource.ValueType  # 3
        """Explicit match based on the activation of the persona by an agent (usually a metadata input)."""
        MATCH_SOURCE_FRAGMENT: InputsIntentsAnnotation._MatchSource.ValueType  # 4
        """Explicit match based on added fragment, that contain this input and potentially previous inputs.
        The last input of the fragment (usually a client's input) is the one on which this match is added.
        """
        MATCH_SOURCE_CLASSIFIER: InputsIntentsAnnotation._MatchSource.ValueType  # 5
        """Matched by the playbook's intent classifier"""
        MATCH_SOURCE_TEMPLATE_CLASSIFIER: InputsIntentsAnnotation._MatchSource.ValueType  # 6
        """Matched by a template classifier"""
        MATCH_SOURCE_TRAINING_PHRASE_CONTENT: InputsIntentsAnnotation._MatchSource.ValueType  # 7
        """Matched because an existing training phrase has the same normalized text"""
        MATCH_SOURCE_EVALUATION_RUN: InputsIntentsAnnotation._MatchSource.ValueType  # 8
        """Matched by evaluation run"""

    class MatchSource(_MatchSource, metaclass=_MatchSourceEnumTypeWrapper): ...
    MATCH_SOURCE_INVALID: InputsIntentsAnnotation.MatchSource.ValueType  # 0
    MATCH_SOURCE_INTENT_MODEL: InputsIntentsAnnotation.MatchSource.ValueType  # 1
    """Intent match based on IntentModel on expert/agent or client inputs."""
    MATCH_SOURCE_SUGGESTED_ENTRY: InputsIntentsAnnotation.MatchSource.ValueType  # 2
    """Explicit match based on usage of a suggested entry (or modified suggested entry) by the agent."""
    MATCH_SOURCE_PERSONA_ACTIVATION: InputsIntentsAnnotation.MatchSource.ValueType  # 3
    """Explicit match based on the activation of the persona by an agent (usually a metadata input)."""
    MATCH_SOURCE_FRAGMENT: InputsIntentsAnnotation.MatchSource.ValueType  # 4
    """Explicit match based on added fragment, that contain this input and potentially previous inputs.
    The last input of the fragment (usually a client's input) is the one on which this match is added.
    """
    MATCH_SOURCE_CLASSIFIER: InputsIntentsAnnotation.MatchSource.ValueType  # 5
    """Matched by the playbook's intent classifier"""
    MATCH_SOURCE_TEMPLATE_CLASSIFIER: InputsIntentsAnnotation.MatchSource.ValueType  # 6
    """Matched by a template classifier"""
    MATCH_SOURCE_TRAINING_PHRASE_CONTENT: InputsIntentsAnnotation.MatchSource.ValueType  # 7
    """Matched because an existing training phrase has the same normalized text"""
    MATCH_SOURCE_EVALUATION_RUN: InputsIntentsAnnotation.MatchSource.ValueType  # 8
    """Matched by evaluation run"""

    class Match(google.protobuf.message.Message):
        """One intent match of a given input"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        INTENT_ID_FIELD_NUMBER: builtins.int
        SCORE_FIELD_NUMBER: builtins.int
        SOURCE_FIELD_NUMBER: builtins.int
        SOURCE_ID_FIELD_NUMBER: builtins.int
        SOURCE_IS_EXPLICIT_FIELD_NUMBER: builtins.int
        PARENTS_FIELD_NUMBER: builtins.int
        MODEL_ID_FIELD_NUMBER: builtins.int
        RUN_ID_FIELD_NUMBER: builtins.int
        intent_id: builtins.str
        score: builtins.float
        source: global___InputsIntentsAnnotation.MatchSource.ValueType
        source_id: builtins.str
        """Unique identifier of the source if applicable (ex: training phrase id if fragment match)"""
        source_is_explicit: builtins.bool
        """This field will be true if source is an explicit one. See comment on each value of `MatchSource`."""
        @property
        def parents(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InputsIntentsAnnotation.Match]: ...
        model_id: builtins.str
        """Unique identifier of the model used for intent inference."""
        run_id: builtins.str
        """(Optional) Unique identifier of the pipeline run that added this match.
        At the moment, this is only populated if the match was added by an evaluation run.
        """
        def __init__(
            self,
            *,
            intent_id: builtins.str = ...,
            score: builtins.float = ...,
            source: global___InputsIntentsAnnotation.MatchSource.ValueType = ...,
            source_id: builtins.str = ...,
            source_is_explicit: builtins.bool = ...,
            parents: collections.abc.Iterable[global___InputsIntentsAnnotation.Match] | None = ...,
            model_id: builtins.str = ...,
            run_id: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["intent_id", b"intent_id", "model_id", b"model_id", "parents", b"parents", "run_id", b"run_id", "score", b"score", "source", b"source", "source_id", b"source_id", "source_is_explicit", b"source_is_explicit"]) -> None: ...

    class InputMatches(google.protobuf.message.Message):
        """All intent matches for a given input"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        MATCHES_FIELD_NUMBER: builtins.int
        @property
        def matches(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InputsIntentsAnnotation.Match]: ...
        def __init__(
            self,
            *,
            matches: collections.abc.Iterable[global___InputsIntentsAnnotation.Match] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["matches", b"matches"]) -> None: ...

    INPUTS_FIELD_NUMBER: builtins.int
    CLIENT_INPUT_COUNT_FIELD_NUMBER: builtins.int
    @property
    def inputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InputsIntentsAnnotation.InputMatches]:
        """One data element per input."""
    client_input_count: builtins.int
    """Total number of inputs made by client in the conversation.
    Needed since the input intent annotation may be used in a side channel without conversation
    and is required for intent predicate.
    """
    def __init__(
        self,
        *,
        inputs: collections.abc.Iterable[global___InputsIntentsAnnotation.InputMatches] | None = ...,
        client_input_count: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["client_input_count", b"client_input_count", "inputs", b"inputs"]) -> None: ...

global___InputsIntentsAnnotation = InputsIntentsAnnotation

class LanguageAnnotation(google.protobuf.message.Message):
    """Language detection annotation"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class InputLanguage(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        LANGUAGE_FIELD_NUMBER: builtins.int
        CONFIDENCE_FIELD_NUMBER: builtins.int
        language: builtins.str
        """2 letters ISO 639-1 or BCP47 locale format (ex: 'en-US')"""
        confidence: builtins.float
        """Confidence of the language detection"""
        def __init__(
            self,
            *,
            language: builtins.str = ...,
            confidence: builtins.float = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["confidence", b"confidence", "language", b"language"]) -> None: ...

    LANGUAGE_FIELD_NUMBER: builtins.int
    CONFIDENCE_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    language: builtins.str
    """2 letters ISO 639-1 or BCP47 locale format (ex: 'en-US')"""
    confidence: builtins.float
    """Confidence of the language detection"""
    @property
    def inputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LanguageAnnotation.InputLanguage]:
        """Language detection of the inputs of the conversation"""
    def __init__(
        self,
        *,
        language: builtins.str = ...,
        confidence: builtins.float = ...,
        inputs: collections.abc.Iterable[global___LanguageAnnotation.InputLanguage] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["confidence", b"confidence", "inputs", b"inputs", "language", b"language"]) -> None: ...

global___LanguageAnnotation = LanguageAnnotation

class DistributionMetricAnnotation(google.protobuf.message.Message):
    """Holds information about the distribution of probabilities for each input"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class Metric(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENTROPY_FIELD_NUMBER: builtins.int
        UNCERTAINTY_FIELD_NUMBER: builtins.int
        MARGIN_FIELD_NUMBER: builtins.int
        MARGIN_RATIO_FIELD_NUMBER: builtins.int
        VALID_FIELD_NUMBER: builtins.int
        MODEL_ID_FIELD_NUMBER: builtins.int
        entropy: builtins.float
        """Normalized entropy across all probabilities
        -sum(prob * log2(prob)) / log2(n_intents)
        """
        uncertainty: builtins.float
        """Scores unlabeled instances having the highest uncertainty for the top match
        1 - (top match score)
        """
        margin: builtins.float
        """Scores unlabeled instances having the smallest difference between their first and second
        most probable labels.
        1 - ((top match) - (second top match))
        """
        margin_ratio: builtins.float
        """Scores unlabeled instances having the smallest ratio between their second and top score
        most probable labels.
        (2nd top match / top match)
        """
        valid: builtins.bool
        """True if the data is valid for this input"""
        model_id: builtins.str
        """Unique identifier of the model used for intent inference."""
        def __init__(
            self,
            *,
            entropy: builtins.float = ...,
            uncertainty: builtins.float = ...,
            margin: builtins.float = ...,
            margin_ratio: builtins.float = ...,
            valid: builtins.bool = ...,
            model_id: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["entropy", b"entropy", "margin", b"margin", "margin_ratio", b"margin_ratio", "model_id", b"model_id", "uncertainty", b"uncertainty", "valid", b"valid"]) -> None: ...

    class InputMetrics(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        METRICS_FIELD_NUMBER: builtins.int
        @property
        def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DistributionMetricAnnotation.Metric]: ...
        def __init__(
            self,
            *,
            metrics: collections.abc.Iterable[global___DistributionMetricAnnotation.Metric] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["metrics", b"metrics"]) -> None: ...

    METRICS_FIELD_NUMBER: builtins.int
    INPUT_METRICS_FIELD_NUMBER: builtins.int
    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DistributionMetricAnnotation.Metric]:
        """Per input metrics
        Deprecated, use `input_metrics` to support multi model
        """
    @property
    def input_metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DistributionMetricAnnotation.InputMetrics]:
        """Per input metrics"""
    def __init__(
        self,
        *,
        metrics: collections.abc.Iterable[global___DistributionMetricAnnotation.Metric] | None = ...,
        input_metrics: collections.abc.Iterable[global___DistributionMetricAnnotation.InputMetrics] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["input_metrics", b"input_metrics", "metrics", b"metrics"]) -> None: ...

global___DistributionMetricAnnotation = DistributionMetricAnnotation

class EmbeddingMetricAnnotation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class InputMetrics(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NEAREST_NEIGHBOUR_DISTANCES_FIELD_NUMBER: builtins.int
        @property
        def nearest_neighbour_distances(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
            """Sorted distances (closest to farthest) to the neighbours of the input in
            the embedding space. Used for density sorting.
            """
        def __init__(
            self,
            *,
            nearest_neighbour_distances: collections.abc.Iterable[builtins.float] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["nearest_neighbour_distances", b"nearest_neighbour_distances"]) -> None: ...

    INPUT_METRICS_FIELD_NUMBER: builtins.int
    @property
    def input_metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EmbeddingMetricAnnotation.InputMetrics]: ...
    def __init__(
        self,
        *,
        input_metrics: collections.abc.Iterable[global___EmbeddingMetricAnnotation.InputMetrics] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["input_metrics", b"input_metrics"]) -> None: ...

global___EmbeddingMetricAnnotation = EmbeddingMetricAnnotation

class EntityAnnotation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _MatchSource:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _MatchSourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[EntityAnnotation._MatchSource.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        MATCH_SOURCE_INVALID: EntityAnnotation._MatchSource.ValueType  # 0
        MATCH_SOURCE_TRAINING_PHRASE: EntityAnnotation._MatchSource.ValueType  # 1
        MATCH_SOURCE_CLASSIFIER: EntityAnnotation._MatchSource.ValueType  # 2

    class MatchSource(_MatchSource, metaclass=_MatchSourceEnumTypeWrapper): ...
    MATCH_SOURCE_INVALID: EntityAnnotation.MatchSource.ValueType  # 0
    MATCH_SOURCE_TRAINING_PHRASE: EntityAnnotation.MatchSource.ValueType  # 1
    MATCH_SOURCE_CLASSIFIER: EntityAnnotation.MatchSource.ValueType  # 2

    class Match(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        MATCH_FIELD_NUMBER: builtins.int
        SCORE_FIELD_NUMBER: builtins.int
        MODEL_ID_FIELD_NUMBER: builtins.int
        SOURCE_FIELD_NUMBER: builtins.int
        @property
        def match(self) -> playbook.entity_pb2.InputEntity:
            """Entity match (span + reference)"""
        score: builtins.float
        """Matching score"""
        model_id: builtins.str
        """Unique identifier of the model used for entity inference."""
        source: global___EntityAnnotation.MatchSource.ValueType
        """Source of the match"""
        def __init__(
            self,
            *,
            match: playbook.entity_pb2.InputEntity | None = ...,
            score: builtins.float = ...,
            model_id: builtins.str = ...,
            source: global___EntityAnnotation.MatchSource.ValueType = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["match", b"match"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["match", b"match", "model_id", b"model_id", "score", b"score", "source", b"source"]) -> None: ...

    class InputEntities(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        MATCHES_FIELD_NUMBER: builtins.int
        @property
        def matches(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EntityAnnotation.Match]:
            """Matches of the input"""
        def __init__(
            self,
            *,
            matches: collections.abc.Iterable[global___EntityAnnotation.Match] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["matches", b"matches"]) -> None: ...

    INPUT_ENTITIES_FIELD_NUMBER: builtins.int
    @property
    def input_entities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EntityAnnotation.InputEntities]:
        """By input index"""
    def __init__(
        self,
        *,
        input_entities: collections.abc.Iterable[global___EntityAnnotation.InputEntities] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["input_entities", b"input_entities"]) -> None: ...

global___EntityAnnotation = EntityAnnotation

class ParsedInputEntity(google.protobuf.message.Message):
    """Parsed version of the entity annotation, containing both the offsets and parts representations"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class InputPart(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class Text(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            TEXT_FIELD_NUMBER: builtins.int
            text: builtins.str
            def __init__(
                self,
                *,
                text: builtins.str = ...,
            ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["text", b"text"]) -> None: ...

        TEXT_FIELD_NUMBER: builtins.int
        ENTITY_FIELD_NUMBER: builtins.int
        @property
        def text(self) -> global___ParsedInputEntity.InputPart.Text: ...
        @property
        def entity(self) -> global___EntityAnnotation.Match: ...
        def __init__(
            self,
            *,
            text: global___ParsedInputEntity.InputPart.Text | None = ...,
            entity: global___EntityAnnotation.Match | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["entity", b"entity", "text", b"text", "type", b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["entity", b"entity", "text", b"text", "type", b"type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["type", b"type"]) -> typing_extensions.Literal["text", "entity"] | None: ...

    MODEL_ID_FIELD_NUMBER: builtins.int
    ENTITIES_FIELD_NUMBER: builtins.int
    PARTS_FIELD_NUMBER: builtins.int
    model_id: builtins.str
    @property
    def entities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EntityAnnotation.Match]: ...
    @property
    def parts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ParsedInputEntity.InputPart]: ...
    def __init__(
        self,
        *,
        model_id: builtins.str = ...,
        entities: collections.abc.Iterable[global___EntityAnnotation.Match] | None = ...,
        parts: collections.abc.Iterable[global___ParsedInputEntity.InputPart] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entities", b"entities", "model_id", b"model_id", "parts", b"parts"]) -> None: ...

global___ParsedInputEntity = ParsedInputEntity

class ConversationSource(google.protobuf.message.Message):
    """Source of a conversation with its original information. This is used to annotate conversation with original
    information when conversations are merged / consolidated since they can be coming from different places (ex: Mongo + Thrutext)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Source:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ConversationSource._Source.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        CONVERSATION_SOURCE_INVALID: ConversationSource._Source.ValueType  # 0
        CONVERSATION_SOURCE_MONGODB: ConversationSource._Source.ValueType  # 1
        CONVERSATION_SOURCE_LIVECHAT: ConversationSource._Source.ValueType  # 2
        CONVERSATION_SOURCE_THRUTEXT: ConversationSource._Source.ValueType  # 3
        CONVERSATION_SOURCE_TEXTMAGIC: ConversationSource._Source.ValueType  # 4
        CONVERSATION_SOURCE_FRONT: ConversationSource._Source.ValueType  # 5
        CONVERSATION_SOURCE_ZENDESK: ConversationSource._Source.ValueType  # 6
        CONVERSATION_SOURCE_TAWKTO: ConversationSource._Source.ValueType  # 7
        CONVERSATION_SOURCE_INTERCOM: ConversationSource._Source.ValueType  # 8
        CONVERSATION_SOURCE_OLARK: ConversationSource._Source.ValueType  # 9
        CONVERSATION_SOURCE_SNAPENGAGE: ConversationSource._Source.ValueType  # 10
        CONVERSATION_SOURCE_MONGODB_V2: ConversationSource._Source.ValueType  # 11
        CONVERSATION_SOURCE_USER_UPLOAD: ConversationSource._Source.ValueType  # 12

    class Source(_Source, metaclass=_SourceEnumTypeWrapper): ...
    CONVERSATION_SOURCE_INVALID: ConversationSource.Source.ValueType  # 0
    CONVERSATION_SOURCE_MONGODB: ConversationSource.Source.ValueType  # 1
    CONVERSATION_SOURCE_LIVECHAT: ConversationSource.Source.ValueType  # 2
    CONVERSATION_SOURCE_THRUTEXT: ConversationSource.Source.ValueType  # 3
    CONVERSATION_SOURCE_TEXTMAGIC: ConversationSource.Source.ValueType  # 4
    CONVERSATION_SOURCE_FRONT: ConversationSource.Source.ValueType  # 5
    CONVERSATION_SOURCE_ZENDESK: ConversationSource.Source.ValueType  # 6
    CONVERSATION_SOURCE_TAWKTO: ConversationSource.Source.ValueType  # 7
    CONVERSATION_SOURCE_INTERCOM: ConversationSource.Source.ValueType  # 8
    CONVERSATION_SOURCE_OLARK: ConversationSource.Source.ValueType  # 9
    CONVERSATION_SOURCE_SNAPENGAGE: ConversationSource.Source.ValueType  # 10
    CONVERSATION_SOURCE_MONGODB_V2: ConversationSource.Source.ValueType  # 11
    CONVERSATION_SOURCE_USER_UPLOAD: ConversationSource.Source.ValueType  # 12

    ID_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    CONVERTED_PATH_FIELD_NUMBER: builtins.int
    CONVERSATION_SOURCE_ID_FIELD_NUMBER: builtins.int
    IMPORT_FORMAT_FIELD_NUMBER: builtins.int
    SOURCE_PATH_FIELD_NUMBER: builtins.int
    PIPELINE_PATH_FIELD_NUMBER: builtins.int
    PIPELINE_PATH_SEQ_FIELD_NUMBER: builtins.int
    id: builtins.str
    """Conversation identifier used by the source"""
    source: global___ConversationSource.Source.ValueType
    """Name of the source"""
    converted_path: builtins.str
    """Path where this conversation was imported from"""
    conversation_source_id: builtins.str
    """ID ConversationSource in which this conversation was imported"""
    import_format: global___ConversationsImportFormat.ValueType
    """Format from which we imported this conversation from the source"""
    source_path: builtins.str
    """If source is file based, file in which this conversation was at source"""
    pipeline_path: builtins.str
    """Path of the file in which the conversation is in the latest pipeline job"""
    pipeline_path_seq: builtins.int
    """The sequence in which this conversation was located within `pipeline_path`
    This is used to write the conversations back in the right order in the file.
    """
    def __init__(
        self,
        *,
        id: builtins.str = ...,
        source: global___ConversationSource.Source.ValueType = ...,
        converted_path: builtins.str = ...,
        conversation_source_id: builtins.str = ...,
        import_format: global___ConversationsImportFormat.ValueType = ...,
        source_path: builtins.str = ...,
        pipeline_path: builtins.str = ...,
        pipeline_path_seq: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["conversation_source_id", b"conversation_source_id", "converted_path", b"converted_path", "id", b"id", "import_format", b"import_format", "pipeline_path", b"pipeline_path", "pipeline_path_seq", b"pipeline_path_seq", "source", b"source", "source_path", b"source_path"]) -> None: ...

global___ConversationSource = ConversationSource

class ConversationSetSource(google.protobuf.message.Message):
    """Source of the conversation when it was processed in the pipeline and selected from a conversation set."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONVERSATION_SET_ID_FIELD_NUMBER: builtins.int
    conversation_set_id: builtins.str
    """ID of the conversation set"""
    def __init__(
        self,
        *,
        conversation_set_id: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["conversation_set_id", b"conversation_set_id"]) -> None: ...

global___ConversationSetSource = ConversationSetSource

class ConversationTelemetry(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VISITOR_ID_FIELD_NUMBER: builtins.int
    ACTIONS_FIELD_NUMBER: builtins.int
    visitor_id: builtins.str
    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TurnAction]: ...
    def __init__(
        self,
        *,
        visitor_id: builtins.str = ...,
        actions: collections.abc.Iterable[global___TurnAction] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions", b"actions", "visitor_id", b"visitor_id"]) -> None: ...

global___ConversationTelemetry = ConversationTelemetry

class TurnAction(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    type: builtins.str
    @property
    def payload(self) -> google.protobuf.struct_pb2.Struct: ...
    def __init__(
        self,
        *,
        type: builtins.str = ...,
        payload: google.protobuf.struct_pb2.Struct | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["payload", b"payload"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["payload", b"payload", "type", b"type"]) -> None: ...

global___TurnAction = TurnAction

class FeatureFlags(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IS_INLINE_AUTOCOMPLETE_ACTIVE_FIELD_NUMBER: builtins.int
    IS_FULL_AUTOCOMPLETE_ACTIVE_FIELD_NUMBER: builtins.int
    IS_PREDICTIVE_RESPONSE_ACTIVE_FIELD_NUMBER: builtins.int
    MODEL_PREDICTIVE_ENABLED_FIELD_NUMBER: builtins.int
    MODEL_SEQUENCE_ENABLED_FIELD_NUMBER: builtins.int
    is_inline_autocomplete_active: builtins.bool
    is_full_autocomplete_active: builtins.bool
    is_predictive_response_active: builtins.bool
    model_predictive_enabled: builtins.bool
    model_sequence_enabled: builtins.bool
    def __init__(
        self,
        *,
        is_inline_autocomplete_active: builtins.bool = ...,
        is_full_autocomplete_active: builtins.bool = ...,
        is_predictive_response_active: builtins.bool = ...,
        model_predictive_enabled: builtins.bool = ...,
        model_sequence_enabled: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["is_full_autocomplete_active", b"is_full_autocomplete_active", "is_inline_autocomplete_active", b"is_inline_autocomplete_active", "is_predictive_response_active", b"is_predictive_response_active", "model_predictive_enabled", b"model_predictive_enabled", "model_sequence_enabled", b"model_sequence_enabled"]) -> None: ...

global___FeatureFlags = FeatureFlags

class Agent(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    EMAIL_FIELD_NUMBER: builtins.int
    FIRST_NAME_FIELD_NUMBER: builtins.int
    LAST_NAME_FIELD_NUMBER: builtins.int
    id: builtins.str
    email: builtins.str
    first_name: builtins.str
    last_name: builtins.str
    def __init__(
        self,
        *,
        id: builtins.str = ...,
        email: builtins.str = ...,
        first_name: builtins.str = ...,
        last_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["email", b"email", "first_name", b"first_name", "id", b"id", "last_name", b"last_name"]) -> None: ...

global___Agent = Agent

class Application(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Type:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Application._Type.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: Application._Type.ValueType  # 0
        AGENT_EXTENSION: Application._Type.ValueType  # 1
        AUTOMATE_WIDGET: Application._Type.ValueType  # 2

    class Type(_Type, metaclass=_TypeEnumTypeWrapper): ...
    UNKNOWN: Application.Type.ValueType  # 0
    AGENT_EXTENSION: Application.Type.ValueType  # 1
    AUTOMATE_WIDGET: Application.Type.ValueType  # 2

    TYPE_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    type: global___Application.Type.ValueType
    version: builtins.str
    def __init__(
        self,
        *,
        type: global___Application.Type.ValueType = ...,
        version: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["type", b"type", "version", b"version"]) -> None: ...

global___Application = Application
